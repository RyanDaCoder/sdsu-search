generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// Enums so filters are consistent
enum Modality {
  IN_PERSON
  ONLINE_SYNC
  ONLINE_ASYNC
  HYBRID
  UNKNOWN
}

enum SectionStatus {
  OPEN
  CLOSED
  WAITLIST
  UNKNOWN
}

// Core Models
model Term {
  id       String    @id @default(cuid())
  code     String    @unique // "20251" or "Fall2025" (your choice later)
  name     String // "Fall 2025"
  startsAt DateTime?
  endsAt   DateTime?

  sections Section[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Course {
  id      String  @id @default(cuid())
  subject String // "CS"
  number  String // "210" or "250A"
  title   String?
  units   String? // keep flexible; ranges happen

  sections     Section[]
  requirements CourseRequirement[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([subject, number])
  @@index([subject, number])
  @@index([title])
}

model Section {
  id String @id @default(cuid())

  termId   String
  courseId String

  classNumber String? // SDSU class #
  sectionCode String? // "01", "02", etc

  modality Modality      @default(UNKNOWN)
  status   SectionStatus @default(UNKNOWN)
  campus   String?

  capacity Int?
  enrolled Int?
  waitlist Int?

  // Relations
  meetings    Meeting[]
  instructors SectionInstructor[]

  term   Term   @relation(fields: [termId], references: [id], onDelete: Cascade)
  course Course @relation(fields: [courseId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([termId, classNumber])
  @@index([termId])
  @@index([courseId])
  @@index([termId, modality])
  @@index([termId, status])
}

// Meetings = where day/time/location live
model Meeting {
  id String @id @default(cuid())

  sectionId String

  days     String? // "MWF", "TR", "TBA"
  startMin Int? // minutes from midnight (9:00 AM -> 540)
  endMin   Int?

  building String?
  room     String?
  location String? // optional combined location

  section Section @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([sectionId])
  @@index([days])
  @@index([startMin, endMin])
}

model Instructor {
  id    String  @id @default(cuid())
  name  String
  email String?

  sections SectionInstructor[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name])
  @@index([name])
}

// Join table so a Section can have multiple instructors
model SectionInstructor {
  sectionId    String
  instructorId String

  section    Section    @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  instructor Instructor @relation(fields: [instructorId], references: [id], onDelete: Cascade)

  @@id([sectionId, instructorId])
  @@index([instructorId])
}

// GE / Requirements
model Requirement {
  id          String  @id @default(cuid())
  code        String  @unique // "GE-IIB", "GE-IVC", etc.
  name        String?
  description String?

  courses CourseRequirement[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([code])
}

// Join table for Course <-> Requirement many-to-many
model CourseRequirement {
  courseId      String
  requirementId String

  course      Course      @relation(fields: [courseId], references: [id], onDelete: Cascade)
  requirement Requirement @relation(fields: [requirementId], references: [id], onDelete: Cascade)

  @@id([courseId, requirementId])
  @@index([requirementId])
}
